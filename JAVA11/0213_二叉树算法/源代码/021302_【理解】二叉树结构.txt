1、
package cn.mldn.util;

public interface IBinaryTree<T> {
    public void add(T data) ;
    public int size() ;
    public Object[] toArray() ;
}


2、
package cn.mldn.util.impl;

import cn.mldn.util.IBinaryTree;

public class BinaryTreeImpl<T> implements IBinaryTree<T> {
    private class Node {
        private Comparable<T> data ; // 存储数据
        private Node left ;
        private Node right ;
        private Node parent ;
        public Node(Comparable<T> data) {
            this.data = data ;
        }
        public void addNode(Node parentNode, Node newNode) {
            if (this.data.compareTo((T)newNode.data) <= 0) { // 当前节点小于传进来的节点
                if (this.right == null) {   // 右节点为空
                    this.right = newNode ;
                    newNode.parent = parentNode ;
                } else {
                    this.right.addNode(this,newNode);
                }
            } else {
                if(this.left == null) {
                    this.left = newNode ;
                    newNode.parent = parentNode ;
                } else {
                    this.left.addNode(this,newNode);
                }
            }
        }
        public void toArrayNode() { // 中序遍历
            if (this.left != null) {
                this.left.toArrayNode();
            }
            BinaryTreeImpl.this.returnData[BinaryTreeImpl.this.foot ++] = (T) this.data ; // 获取数据
            if (this.right != null) {
                this.right.toArrayNode();
            }
        }
    }
    // ----------------------------------------------------------------- //
    private Node root ; // 保存根节点
    private int size ; // 保存元素的个数
    private Object [] returnData ;
    private int foot ; // 作为操作脚标
    @Override
    public void add(T data) {
        if (data == null) {
            return ;
        }
        Comparable obj = (Comparable) data ;    // 强制转换，如果未实现接口会产生异常
        Node newNode = new Node(obj) ; // 定义节点对象
        if (this.root == null) {    // 当前没有根节点
            this.root = newNode ; // 第一个节点作为根节点
        } else {
            this.root.addNode(this.root,newNode);
        }
        this.size ++ ;  // 个数增加
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public Object[] toArray() {
        if (this.size == 0) {
            return null ;
        }
        this.foot = 0 ; // 脚标清零
        this.returnData = new Object[this.size] ;
        this.root.toArrayNode() ;
        return this.returnData;
    }
}


3、

package cn.mldn.test;

import cn.mldn.util.IBinaryTree;
import cn.mldn.util.impl.BinaryTreeImpl;

import java.util.Arrays;

class Member implements Comparable<Member> {
    private String name ;
    private int age ;
    public Member(String name,int age) {
        this.name = name ;
        this.age = age ;
    }
    @Override
    public String toString() {
        return "姓名：" + this.name + "、年龄：" + this.age + "\n" ;
    }
    @Override
    public int compareTo(Member o) {
        return this.age - o.age;
    }
}
public class TestBinaryTree {
    public static void main(String[] args) {
        IBinaryTree bt = new BinaryTreeImpl() ;
        bt.add(new Member("张三",10));
        bt.add(new Member("李四",11));
        bt.add(new Member("王五",9));
        bt.add(new Member("赵六",12));
        bt.add(new Member("孙七",12));
        Object result [] = bt.toArray() ;
        System.out.println(Arrays.toString(result));
    }
}


4、
package cn.mldn.util;

public interface IBinaryTree<T> {
    public void add(T data) ;
    public int size() ;
    public Object[] toArray() ;
    public boolean contains(T data) ;
}


5、
package cn.mldn.util.impl;

import cn.mldn.util.IBinaryTree;

public class BinaryTreeImpl<T> implements IBinaryTree<T> {
    private class Node {
        private Comparable<T> data ; // 存储数据
        private Node left ;
        private Node right ;
        private Node parent ;
        public Node(Comparable<T> data) {
            this.data = data ;
        }
        public void addNode(Node parentNode, Node newNode) {
            if (this.data.compareTo((T)newNode.data) <= 0) { // 当前节点小于传进来的节点
                if (this.right == null) {   // 右节点为空
                    this.right = newNode ;
                    newNode.parent = parentNode ;
                } else {
                    this.right.addNode(this,newNode);
                }
            } else {
                if(this.left == null) {
                    this.left = newNode ;
                    newNode.parent = parentNode ;
                } else {
                    this.left.addNode(this,newNode);
                }
            }
        }
        public void toArrayNode() { // 中序遍历
            if (this.left != null) {
                this.left.toArrayNode();
            }
            BinaryTreeImpl.this.returnData[BinaryTreeImpl.this.foot ++] = (T) this.data ; // 获取数据
            if (this.right != null) {
                this.right.toArrayNode();
            }
        }
        public boolean containsNode(T data) { // 要查询的数据
            if (this.data.compareTo(data) == 0){    // 数据已经查找到了
                return true ;
            } else {    // 判断大于还是小于
                if (this.data.compareTo(data) < 0) {
                    if (this.right != null) {
                        return this.right.containsNode(data) ;
                    } else {
                        return false ;
                    }
                } else {
                    if (this.left != null) {
                        return this.left.containsNode(data) ;
                    } else {
                        return false ;
                    }
                }
            }
        }
    }
    // ----------------------------------------------------------------- //
    private Node root ; // 保存根节点
    private int size ; // 保存元素的个数
    private Object [] returnData ;
    private int foot ; // 作为操作脚标
    @Override
    public void add(T data) {
        if (data == null) {
            return ;
        }
        Comparable obj = (Comparable) data ;    // 强制转换，如果未实现接口会产生异常
        Node newNode = new Node(obj) ; // 定义节点对象
        if (this.root == null) {    // 当前没有根节点
            this.root = newNode ; // 第一个节点作为根节点
        } else {
            this.root.addNode(this.root,newNode);
        }
        this.size ++ ;  // 个数增加
    }

    @Override
    public int size() {
        return this.size;
    }

    @Override
    public Object[] toArray() {
        if (this.size == 0) {
            return null ;
        }
        this.foot = 0 ; // 脚标清零
        this.returnData = new Object[this.size] ;
        this.root.toArrayNode() ;
        return this.returnData;
    }

    @Override
    public boolean contains(T data) {
        if (this.size == 0) {
            return false ;
        }
        return this.root.containsNode(data);
    }
}


6、
package cn.mldn.test;

import cn.mldn.util.IBinaryTree;
import cn.mldn.util.impl.BinaryTreeImpl;

class Member implements Comparable<Member> {
    private String name ;
    private int age ;
    public Member(String name,int age) {
        this.name = name ;
        this.age = age ;
    }
    @Override
    public String toString() {
        return "姓名：" + this.name + "、年龄：" + this.age + "\n" ;
    }
    @Override
    public int compareTo(Member o) {
        if (this.age < o.age) {
            return -1 ;
        } else if (this.age > o.age) {
            return 1 ;
        } else {
            return this.name.compareTo(o.name) ;
        }
    }
}
public class TestBinaryTree {
    public static void main(String[] args) {
        IBinaryTree bt = new BinaryTreeImpl() ;
        bt.add(new Member("张三",10));
        bt.add(new Member("李四",11));
        bt.add(new Member("王五",9));
        bt.add(new Member("赵六",12));
        bt.add(new Member("孙七",12));
        System.out.println(bt.contains(new Member("王八",12)));
        System.out.println(bt.contains(new Member("赵六",12)));
    }
}

7、
package cn.mldn.util;

public interface IBinaryTree<T> {
    public void add(T data) ;
    public int size() ;
    public Object[] toArray() ;
    public boolean contains(T data) ;
    public void remove(T data) ;
}


8、
package cn.mldn.util.impl;

import cn.mldn.util.IBinaryTree;

public class BinaryTreeImpl<T> implements IBinaryTree<T> {
    private class Node {
        private Comparable<T> data ; // 存储数据
        private Node left ;
        private Node right ;
        private Node parent ;
        public Node(Comparable<T> data) {
            this.data = data ;
        }
        public void addNode(Node parentNode, Node newNode) {
            if (this.data.compareTo((T)newNode.data) <= 0) { // 当前节点小于传进来的节点
                if (this.right == null) {   // 右节点为空
                    this.right = newNode ;
                    newNode.parent = parentNode ;
                } else {
                    this.right.addNode(this.right,newNode);
                }
            } else {
                if(this.left == null) {
                    this.left = newNode ;
                    newNode.parent = parentNode ;
                } else {
                    this.left.addNode(this.left,newNode);
                }
            }
        }
        public void toArrayNode() { // 中序遍历
            if (this.left != null) {
                this.left.toArrayNode();
            }
            BinaryTreeImpl.this.returnData[BinaryTreeImpl.this.foot ++] = (T) this.data ; // 获取数据
            if (this.right != null) {
                this.right.toArrayNode();
            }
        }
        public Node getRemoveNode(T data) { // 得到要删除的节点
            if (this.data.compareTo(data) == 0) {
                return this ; // 返回当前节点
            } else {
                if (this.data.compareTo(data) < 0) {
                    return this.right.getRemoveNode(data) ;
                } else {
                    return this.left.getRemoveNode(data) ;
                }
            }
        }
        public boolean containsNode(T data) { // 要查询的数据
            if (this.data.compareTo(data) == 0){    // 数据已经查找到了
                return true ;
            } else {    // 判断大于还是小于
                if (this.data.compareTo(data) < 0) {
                    if (this.right != null) {
                        return this.right.containsNode(data) ;
                    } else {
                        return false ;
                    }
                } else {
                    if (this.left != null) {
                        return this.left.containsNode(data) ;
                    } else {
                        return false ;
                    }
                }
            }
        }
    }
    // ----------------------------------------------------------------- //
    private Node root ; // 保存根节点
    private int size ; // 保存元素的个数
    private Object [] returnData ;
    private int foot ; // 作为操作脚标
    @Override
    public void add(T data) {
        if (data == null) {
            return ;
        }
        Comparable obj = (Comparable) data ;    // 强制转换，如果未实现接口会产生异常
        Node newNode = new Node(obj) ; // 定义节点对象
        if (this.root == null) {    // 当前没有根节点
            this.root = newNode ; // 第一个节点作为根节点
        } else {
            this.root.addNode(this.root,newNode);
        }
        this.size ++ ;  // 个数增加
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public Object[] toArray() {
        if (this.size == 0) {
            return null ;
        }
        this.foot = 0 ; // 脚标清零
        this.returnData = new Object[this.size] ;
        this.root.toArrayNode() ;
        return this.returnData;
    }
    @Override
    public boolean contains(T data) {
        if (this.size == 0) {
            return false ;
        }
        return this.root.containsNode(data);
    }
    @Override
    public void remove(T data) {
        if (this.contains(data)) {  // 数据存在则进行删除操作
            if (this.root.data.compareTo(data) == 0) {  // 根节点删除
                this.root = this.moveNode(data) ;
            } else {    // 要删除的是后续节点
                this.moveNode(data) ;
            }
            this.size -- ; // 减少保存的个数
        }
    }
    private Node moveNode(T data) {
        Node moveSubNode = null ;
        Node deleteNode = this.root.getRemoveNode(data) ;
        if (deleteNode.left == null && deleteNode.right == null) {  // 是一个独立的节点
            if (deleteNode.parent != null) {
                if (deleteNode.parent.data.compareTo(data) <= 0) {
                    deleteNode.parent.right = null;
                } else {
                    deleteNode.parent.left = null;
                }
            }
            deleteNode.parent = null ; // 取消当前节点的引用
        }
        if ((deleteNode.left != null & deleteNode.right == null)
                || deleteNode.left == null & deleteNode.right != null) {    // 有一个子节点
            moveSubNode = null ; // 要移动的节点，可能是左节点，或者右节点
            if (deleteNode.left != null) {
                moveSubNode = deleteNode.left ;
            } else {
                moveSubNode = deleteNode.right ;
            }
            if (deleteNode.parent != null) {
                if (deleteNode.parent.data.compareTo(data) <= 0) {   // 右节点
                    deleteNode.parent.right = moveSubNode;  // 移动子节点
                } else {    // 左节点
                    deleteNode.parent.left = moveSubNode;  // 移动子节点
                }
            }
            moveSubNode.parent = deleteNode.parent ; // 修改父节点
        }
        if (deleteNode.left != null && deleteNode.right != null) {
            moveSubNode = deleteNode.right ; // 获取移动节点
            while (moveSubNode.left != null) {
                this.foot ++ ;
                moveSubNode = moveSubNode.left ; // 找到最左的节点
            }
            if (moveSubNode.right != null) {    // 移动节点存在有右节点
                moveSubNode.parent.left = moveSubNode.right ;
                moveSubNode.right.parent = moveSubNode.parent ;
            } else {
                if (deleteNode.right != moveSubNode) {
                    moveSubNode.parent.left = null; // 删除移动节点对应的左节点
                }
            }
            moveSubNode.parent = deleteNode.parent ; // 改变移动节点的父节点
            moveSubNode.left = deleteNode.left ;
            if (deleteNode.right != moveSubNode) {
                moveSubNode.right = deleteNode.right;
            }
            if (deleteNode.parent != null) {
                if (deleteNode.parent.data.compareTo(data) <= 0) {   // 右节点
                    deleteNode.parent.right = moveSubNode;  // 移动子节点
                } else {    // 左节点
                    deleteNode.parent.left = moveSubNode;  // 移动子节点
                }
            }
        }
        return moveSubNode ;
    }
}


9、

package cn.mldn.test;

import cn.mldn.util.IBinaryTree;
import cn.mldn.util.impl.BinaryTreeImpl;

import java.util.Arrays;

public class TestBinaryTree {
    public static void main(String[] args) {
        IBinaryTree<Integer> bt = new BinaryTreeImpl<Integer>() ;
        bt.add(80);
        bt.add(50);
        bt.add(90);
        bt.add(30);
        bt.add(10);
        bt.add(60);
        bt.add(85);
        bt.add(95);
        bt.add(55);
        bt.add(70);
        bt.remove(80);
        System.out.println(Arrays.toString(bt.toArray()));
    }
}

10、

